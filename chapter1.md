# 理解volatile变量

## 语义

1. 保证此变量对所有线程的可见性
2. 静止指令重排优化

## 阻止重排优化
在执行程序时为了提高性能，编译器和处理器常常会对指令做重排序。重排序分三种类型
1. 编译器优化的重排序。编译器在不改变单线程程序语义的前提下，可以重新安排语句的执行顺序。
2. 指令级并行的重排序。现代处理器采用了指令级并行技术（Instruction-Level Parallelism， ILP）来将多条指令重叠执行。如果不存在数据依赖性，处理器可以改变语句对应机器指令的执行顺序。
3. 内存系统的重排序。由于处理器使用缓存和读/写缓冲区，这使得加载和存储操作看上去可能是在乱序执行。

内存栅栏的目的就是为了阻止上面第2和第3种情况的重排序。

### 内存栅栏

内存栅栏或内存屏障（memory barrier），处理因为重排序带来的同步问题，是处理器提供的一种同步指令。确保此点之前的所有读写操作都执行并同步到内存中。

不同的处理提供不同的指令，比如x86提供的内存栅栏指令`lfence`,`sfence`,`mfence`。

- lfence：指令前所有读取指令（load-from-memory）都必须完成。
- mfence：指令前所有读写指令（load-from-memory and store-to-memory）都必须完成。

java中不用直接涉及内存栅栏，java的内存模型已经处理好了这些。比如java的`volatile`关键字。

volatile修饰的变量多了lock指令，这个指令提供了一个memory barrier（重排序不能把后面的指令，排序到memory barrier的前面）。

>`lock`指令，根据IA32手册描述，作用是把cpu的cache写入内存，同时让其他cpu的缓存无效化。这就可以实现可见性和避免指令乱序，因为内存栅栏（memory barrier）之前的都需要同步到内存中。

## java内存模型

java内存模型屏蔽了各平台内存的差异。定义了对变量的写入操作在何时对其它线程可见。

